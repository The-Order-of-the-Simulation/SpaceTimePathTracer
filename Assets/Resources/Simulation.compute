#pragma kernel GridRaster GRID_RASTERIZER
#pragma kernel PointGen POINT_GEN

#define GROUPTHREADS 1024
float3 Resolution;
int iFrame;
int Length;
int ManipCount;
float Accumulation;
float Param1;

float3 BBoxCenter;
float3 BBoxSize;

#include<Utils.cginc>

uint getGridID(uint3 vox)
{
    return vox.x + uint(Resolution.x) * vox.y +  uint(Resolution.x) * uint(Resolution.y) * vox.z;
}

#ifdef GRID_RASTERIZER

RWStructuredBuffer<uint> AtomicGrid;
StructuredBuffer<float4> Points;

void RasterizePoint(float3 p)
{
    float col = 1.0;// spectral_zucconi(p.w);
    uint id = getGridID(uint3(p.xyz));
    InterlockedAdd(AtomicGrid[id], float2uint(col));
}

[numthreads(GROUPTHREADS, 1, 1)]
void GridRaster(uint3 Gid : SV_GroupID, uint3 DTid : SV_DispatchThreadID, uint3 GTid : SV_GroupThreadID, uint GI : SV_GroupIndex)
{
    uint id = DTid.x;
    float4 p = Points[id];
    state = uint4(id, iFrame, 0, 0);
   
    RasterizePoint(p.xyz);
}

#endif //ATOMIC_RASTERIZER


#ifdef POINT_GEN

RWStructuredBuffer<float4> Points;
StructuredBuffer<float4> Manipulators;

float map(float3 p)
{
	float bound = sdBox(p - BBoxCenter, BBoxSize*0.5);
	return bound;
}

float3 normal(in float3 pos)
{
	float2 e = float2(1.0, -1.0) * 0.5773 * 0.0005;
	return normalize(e.xyy * map(pos + e.xyy).x +
		e.yyx * map(pos + e.yyx).x +
		e.yxy * map(pos + e.yxy).x +
		e.xxx * map(pos + e.xxx).x);
}

float3 bforce(float3 p)
{
    float sdf = map(p);
    float3 N = normal(p);

    return - 40.0 * N * step(0.0, sdf) * abs(sdf);
}

float3 sbf(float3 c, float3 w, float s) {
    float3 k = sin(PI * c * w) * cos(PI * c.yzx * w.yzx) * cos(PI * c.zxy * w.zxy);
    k = lerp(k, k * cross(normalize(w), normalize(float3(2, 4, 1))), s);
    return k;
}

#define SPEED 1.1
#define timescale 0.03

float3 force(float3 p, int id)
{
    float iTime  = timescale*float(iFrame) / 320.0f;
 
    float dc1 = 0.5 + 0.5 * sin(4.0 * iTime);
    float dc2 = 0.5 + 0.5 * cos(6.0 * iTime);
    float3 pd = float3(-3, 3* dc2, 3) + (rand3() - 0.5) * 0.01;
   
    float3 f = 0;
    pd += 600. * sbf(pd, float3(1, 2, 3), .9) / 1300.;
    f += 30. * sbf(p, pd, .9) / 1300.;
    f += 10. * sbf(p.zyx, float3(3, -4, 1) , .9) / 1445.;
    f += 40. * sbf(p.xzy, float3(1, 5, -2) - pd * 0.5, .9) / 753.;

    float d = length(p);
    f +=  (-0.001 * p);

    for(int i = 0; i < ManipCount; i++)
    {
        float4 manip = Manipulators[i];
        float3 dv = manip.xyz - p;
        float d0 = length(dv);
        f += manip.w * dv / (d0 * d0 + 1e-2);
    }

    f += bforce(p);

    return f;
}

[numthreads(GROUPTHREADS, 1, 1)]
void PointGen(uint3 Gid : SV_GroupID, uint3 DTid : SV_DispatchThreadID, uint3 GTid : SV_GroupThreadID, uint GI : SV_GroupIndex)
{
    uint gid = Gid.x;
    uint lid = GTid.x;
    uint id = DTid.x;

    state = uint4(id, iFrame, 0, 0);

    /*float3 z;
    float3 c;
    const int iters = 512;
    const int searchi = 32;

    int i = 0;
    float time = iFrame / 5000.0;
    float po = Param1;// +2 * sin(time);
    int j = 0;
    for (; j < searchi; j++)
    {
        z = 0.0001;
        c = (rand3() - 0.5) * 2.0;

        i = 0;
        for (; i < iters; i++)
        {
            if (length(z) > 4.0) break;

            z = cpow3(z,po) + c;
        }

        if (i > 32 && i < iters) break;
    }

    if (j > searchi - 1)
    {
        for (int i = 0; i < 256; i++)
        {
            Points[256 * id + i] = 0.0;
        }
        return;
    }
    
    int it = clamp(ceil(rand()*(i - 256)), 0, i-256);

    z = 0.0001;
    for (int j = 0; j < it+256; j++)
    {
        z = cpow3(z, po) + c;
        if(j >= it) Points[256 * id + j - it] = float4(z, 380.0 + 1.4 * (j - 20.0));
    }
    */

    float3 p = Points[id];
    float3 v = Points[id + Length];
    float wv = Points[id].w;

    //p = fmod3(p - 0.5, 1.0) + 0.5;

    if (iFrame == 0)
    {
        p = (rand3() - 0.5)*float3(1,0.2,1.0);
        v = cross(p, float3(0, 1, 0));
        float seed = sin(3.*p.x)*0.5 + 0.5;
        wv = seed * 300.0 + 350.0;
    }

    float dt = timescale* 1.0 * Param1;

    v += dt * (force(p, id) - 0.02*v);
    //v = force(p, id);
    p += dt * v;


    Points[id] = float4(p, wv);
    Points[id + Length] = float4(v, 0.0);
}

#endif //POINT_GEN